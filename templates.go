package lucidegen

import (
	"os"
	"strings"
	"text/template"
	"time"
)

// Template for individual icon components
const iconsTemplate = `// Code generated by lucide-templ-gen on {{.Timestamp}}. DO NOT EDIT.
// Source: https://github.com/lucide-icons/lucide
// Generator: https://github.com/riclib/lucide-templ-gen

package {{.PackageName}}

import "github.com/a-h/templ"

{{range .Icons}}
// {{.FuncName}} renders the {{.Name}} Lucide icon
// Category: {{.Category}}
templ {{.FuncName}}(attrs templ.Attributes) {
	<svg viewBox="{{.ViewBox}}" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" { attrs... }>
		{{.Content}}
	</svg>
}
{{end}}`

// Template for icon registry
const registryTemplate = `// Code generated by lucide-templ-gen on {{.Timestamp}}. DO NOT EDIT.

package {{.PackageName}}

import "github.com/a-h/templ"

// IconName represents a valid Lucide icon name
type IconName string

// Icon name constants
const (
{{range .Icons}}	{{call $.ToConstantName .Name $.Prefix}} IconName = "{{.Name}}"
{{end}})

// Icon renders any Lucide icon by name with type safety
templ Icon(name IconName, attrs templ.Attributes) {
	switch name {
{{range .Icons}}	case {{call $.ToConstantName .Name $.Prefix}}:
		@{{.FuncName}}(attrs)
{{end}}	}
}

// IconExists checks if an icon name is valid
func IconExists(name string) bool {
	switch IconName(name) {
{{range .Icons}}	case {{call $.ToConstantName .Name $.Prefix}}:
		return true
{{end}}	default:
		return false
	}
}

// AllIcons returns all available icon names
func AllIcons() []IconName {
	return []IconName{
{{range .Icons}}		{{call $.ToConstantName .Name $.Prefix}},
{{end}}	}
}

// IconCount returns the total number of available icons
func IconCount() int {
	return {{len .Icons}}
}

// IconByName returns the IconName for a string name if it exists
func IconByName(name string) (IconName, bool) {
	iconName := IconName(name)
	if IconExists(name) {
		return iconName, true
	}
	return "", false
}`

// Template for categorized icon access
const categoriesTemplate = `// Code generated by lucide-templ-gen on {{.Timestamp}}. DO NOT EDIT.

package {{.PackageName}}

// Category name constants
const (
{{range .Categories}}	Category{{call $.ToCategoryName .}} = "{{.}}"
{{end}})

{{range $category := .Categories}}
// {{call $.ToCategoryName $category}}Icons returns all {{$category}} category icons
func {{call $.ToCategoryName $category}}Icons() []IconName {
	return []IconName{
{{range $.Icons}}{{if eq .Category $category}}		{{call $.ToConstantName .Name $.Prefix}},
{{end}}{{end}}	}
}
{{end}}

// IconsByCategory returns icons grouped by category
func IconsByCategory() map[string][]IconName {
	return map[string][]IconName{
{{range $category := .Categories}}		Category{{call $.ToCategoryName $category}}: {{call $.ToCategoryName $category}}Icons(),
{{end}}	}
}

// GetIconCategory returns the category for a given icon name
func GetIconCategory(name IconName) string {
	switch name {
{{range .Icons}}	case {{call $.ToConstantName .Name $.Prefix}}:
		return "{{.Category}}"
{{end}}	default:
		return ""
	}
}

// AllCategories returns all available category names
func AllCategories() []string {
	return []string{
{{range .Categories}}		Category{{call $.ToCategoryName .}},
{{end}}	}
}`

// TemplateData holds data for template execution
type TemplateData struct {
	PackageName      string
	Prefix           string
	Icons            []IconData
	Categories       []string
	Timestamp        string
	ToConstantName   func(string, string) string
	ToCategoryName   func(string) string
}

// generateIconsFile creates the main icons template file
func generateIconsFile(icons []IconData, config Config, outputPath string) error {
	data := TemplateData{
		PackageName: config.PackageName,
		Prefix:      config.Prefix,
		Icons:       icons,
		Timestamp:   time.Now().Format(time.RFC3339),
	}

	tmpl := template.Must(template.New("icons").Parse(iconsTemplate))
	
	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	return tmpl.Execute(file, data)
}

// generateRegistryFile creates the icon registry file
func generateRegistryFile(icons []IconData, config Config, outputPath string) error {
	data := TemplateData{
		PackageName:    config.PackageName,
		Prefix:         config.Prefix,
		Icons:          icons,
		Timestamp:      time.Now().Format(time.RFC3339),
		ToConstantName: toConstantName,
	}

	tmpl := template.Must(template.New("registry").Parse(registryTemplate))
	
	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	return tmpl.Execute(file, data)
}

// generateCategoriesFile creates the categories file
func generateCategoriesFile(icons []IconData, config Config, outputPath string) error {
	categories := getUniqueCategories(icons)
	
	data := TemplateData{
		PackageName:    config.PackageName,
		Prefix:         config.Prefix,
		Icons:          icons,
		Categories:     categories,
		Timestamp:      time.Now().Format(time.RFC3339),
		ToConstantName: toConstantName,
		ToCategoryName: toCategoryName,
	}

	tmpl := template.Must(template.New("categories").Parse(categoriesTemplate))
	
	file, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer file.Close()

	return tmpl.Execute(file, data)
}

// toCategoryName converts a category name to a function name
func toCategoryName(category string) string {
	// Convert to title case and remove special characters
	parts := strings.Split(category, "-")
	var result strings.Builder
	
	for _, part := range parts {
		if len(part) > 0 {
			result.WriteString(strings.ToUpper(part[:1]))
			if len(part) > 1 {
				result.WriteString(part[1:])
			}
		}
	}
	
	return result.String()
}